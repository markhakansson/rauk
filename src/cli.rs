use serde::Deserialize;
use std::path::PathBuf;
use structopt::StructOpt;

/// Cargo target details
#[derive(Debug, StructOpt, PartialEq, Clone, Deserialize)]
pub struct BuildDetails {
    /// Name of the bin target
    #[structopt(short, long, required_unless = "example", conflicts_with = "example")]
    pub bin: Option<String>,
    /// Name of the example target
    #[structopt(short, long, required_unless = "bin", conflicts_with = "bin")]
    pub example: Option<String>,
    /// Build artifacts in release mode
    #[structopt(short, long)]
    pub release: bool,
}

impl BuildDetails {
    /// Returns the name of the binary/example
    pub fn get_name(&self) -> &str {
        if self.bin.is_some() {
            &self.bin.as_ref().unwrap()
        } else {
            &self.example.as_ref().unwrap()
        }
    }

    pub fn is_example(&self) -> bool {
        if self.example.is_some() {
            true
        } else {
            false
        }
    }

    pub fn is_release(&self) -> bool {
        self.release
    }
}

#[derive(Debug, StructOpt)]
pub struct CliOptions {
    /// Path to the RTIC project directory. Defaults to the current directory if not specified.
    #[structopt(short, long, parse(from_os_str))]
    pub path: Option<PathBuf>,
    /// Path to a rauk config [UNSUPPORTED].
    #[structopt(long, parse(from_os_str))]
    pub config: Option<PathBuf>,
    /// Don't patch the project's Cargo.toml. Will break the tool unless
    /// you don't have the correct dependencies/features set!
    #[structopt(long)]
    pub no_patch: bool,
    /// Verbose output
    #[structopt(short, long)]
    pub verbose: bool,
    #[structopt(subcommand)]
    pub cmd: Command,
}

#[derive(Debug, PartialEq, StructOpt)]
pub enum Command {
    /// Generate test vectors using KLEE
    Generate(GenerateInput),
    /// Build and flash the replay harness onto the target hardware
    Flash(FlashInput),
    /// WCET measure for each task using the test vectors on the replay harness
    Measure(MeasureInput),
    /// Removes all metadata generated by rauk from project directory
    Cleanup,
}

/// Generate test vectors for an RTIC application
#[derive(Debug, PartialEq, Clone, StructOpt, Deserialize)]
pub struct GenerateInput {
    #[structopt(flatten)]
    pub build: BuildDetails,
    #[structopt(skip = false)]
    pub verbose: bool,
    /// Emit all KLEE errors.
    #[structopt(long)]
    pub emit_all_errors: bool,
}

impl GenerateInput {
    pub fn is_release(&self) -> bool {
        self.build.is_release()
    }
}

/// Flashes a binary to the target platform, modified to allow Rauk analysis
#[derive(Debug, PartialEq, Clone, StructOpt, Deserialize)]
pub struct FlashInput {
    #[structopt(flatten)]
    pub build: BuildDetails,
    #[structopt(skip = false)]
    pub verbose: bool,
    /// The target architecture to build the executable for.
    #[structopt(short, long)]
    pub target: Option<String>,
    /// The name of the chip to flash to.
    #[structopt(short, long)]
    pub chip: Option<String>,
}

impl FlashInput {
    pub fn is_release(&self) -> bool {
        self.build.is_release()
    }
}

/// Measures WCET on hardware using the generated tests
#[derive(Debug, PartialEq, Clone, StructOpt, Deserialize)]
pub struct MeasureInput {
    #[structopt(flatten)]
    pub build: BuildDetails,
    /// Path to DWARF.
    #[structopt(short, long, parse(from_os_str))]
    pub dwarf: Option<PathBuf>,
    /// Path to KLEE tests.
    #[structopt(short, long, parse(from_os_str))]
    pub ktests: Option<PathBuf>,
    /// The name of the chip to flash to.
    #[structopt(short, long)]
    pub chip: Option<String>,
}

impl MeasureInput {
    pub fn get_name(&self) -> &str {
        self.build.get_name()
    }

    pub fn is_example(&self) -> bool {
        self.build.is_example()
    }

    pub fn is_release(&self) -> bool {
        self.build.is_release()
    }
}

pub fn get_cli_opts() -> CliOptions {
    CliOptions::from_args()
}
