use serde::Deserialize;
use std::path::PathBuf;
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
pub struct CliOptions {
    /// Path to the RTIC project directory. Defaults to the current directory if not specified.
    #[structopt(short, long, parse(from_os_str))]
    pub path: Option<PathBuf>,
    /// Path to a rauk config [UNSUPPORTED].
    #[structopt(long, parse(from_os_str))]
    pub config: Option<PathBuf>,
    /// Don't patch the project's Cargo.toml. Will break the tool unless
    /// you don't have the correct dependencies/features set!
    #[structopt(long)]
    pub no_patch: bool,
    #[structopt(subcommand)]
    pub cmd: Command,
}

#[derive(Debug, PartialEq, StructOpt)]
pub enum Command {
    Generate(GenerateInput),
    Flash(FlashInput),
    Measure(MeasureInput),
    /// Removes all metadata generated by rauk from project directory
    Cleanup,
}

/// Generate test vectors for an RTIC application
#[derive(Debug, PartialEq, Clone, StructOpt, Deserialize)]
pub struct GenerateInput {
    /// Generate test for a binary target.
    #[structopt(short, long, required_unless = "example", conflicts_with = "example")]
    pub bin: Option<String>,
    /// Generate test for an example.
    #[structopt(short, long, required_unless = "bin", conflicts_with = "bin")]
    pub example: Option<String>,
    /// Generate tests in release mode.
    #[structopt(short, long)]
    pub release: bool,
    /// Enable verbose output
    #[structopt(short, long)]
    pub verbose: bool,
    /// Emit all KLEE errors.
    #[structopt(long)]
    pub emit_all_errors: bool,
}

/// Flashes a binary to the target platform, modified to allow Rauk analysis
#[derive(Debug, PartialEq, Clone, StructOpt, Deserialize)]
pub struct FlashInput {
    /// Name of the binary target to flash.
    #[structopt(short, long, required_unless = "example", conflicts_with = "example")]
    pub bin: Option<String>,
    /// Name of the example to flash.
    #[structopt(short, long, required_unless = "bin", conflicts_with = "bin")]
    pub example: Option<String>,
    /// Build executable in release mode.
    #[structopt(short, long)]
    pub release: bool,
    /// Enable verbose output
    #[structopt(short, long)]
    pub verbose: bool,
    /// The target architecture to build the executable for.
    #[structopt(short, long)]
    pub target: Option<String>,
    /// The name of the chip to flash to.
    #[structopt(short, long)]
    pub chip: Option<String>,
}

/// Measures WCET on hardware using the generated tests
#[derive(Debug, PartialEq, Clone, StructOpt, Deserialize)]
pub struct MeasureInput {
    /// Path to DWARF.
    #[structopt(short, long, parse(from_os_str))]
    pub dwarf: Option<PathBuf>,
    /// Path to KLEE tests.
    #[structopt(short, long, parse(from_os_str))]
    pub ktests: Option<PathBuf>,
    /// The name of the chip to flash to.
    #[structopt(short, long)]
    pub chip: Option<String>,
    /// Measure a flashed binary compiled in relesae
    #[structopt(short, long)]
    pub release: bool,
}

pub fn get_cli_opts() -> CliOptions {
    CliOptions::from_args()
}
